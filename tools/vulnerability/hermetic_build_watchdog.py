#!/usr/bin/env python3
import argparse
import hashlib
import json
import os
import re
import shutil
import signal
import socket
import ssl
import subprocess
import sys
import tempfile
import threading
import time
from contextlib import closing
from pathlib import Path
from typing import Dict, List, Optional, Tuple

ETHICAL_WARNING = (
    "HermeticBuild Watchdog is for authorized testing only. "
    "Do not use against systems, packages, or networks without explicit permission."
)

SENSITIVE_ENV_PREFIXES = [
    "AWS_", "GCP_", "GOOGLE_", "GCS_", "AZURE_", "ARM_", "GCLOUD_", "GITHUB_",
    "GH_", "NPM_TOKEN", "NPM_CONFIG_", "CI_", "TOKEN", "SECRET", "KEY", "PASS",
]
SENSITIVE_ENV_EXACT = [
    "HOME", "SSH_AUTH_SOCK", "SSH_AGENT_PID", "KUBECONFIG", "DOCKER_CONFIG",
    "PIP_INDEX_URL", "PIP_EXTRA_INDEX_URL",
]
SENSITIVE_PATHS = [
    "~/.ssh", "~/.ssh/id_rsa", "~/.ssh/id_ed25519", "~/.aws", "~/.aws/credentials",
    "~/.config/gcloud", "~/.config/gh", "~/.npmrc", "~/.pypirc", "~/.netrc",
    "/var/run/secrets", "/var/run/secrets/kubernetes.io", "/proc/self/environ",
    "/.dockerenv", "/.git-credentials",
]
DEFAULT_REPRO_SEED_ENV = {
    "TZ": "UTC",
    "LANG": "C",
    "LC_ALL": "C",
    "PYTHONHASHSEED": "0",
    "SOURCE_DATE_EPOCH": "1700000000",
    "GIT_AUTHOR_DATE": "1700000000 +0000",
    "GIT_COMMITTER_DATE": "1700000000 +0000",
    "PIP_NO_INPUT": "1",
    "CARGO_TERM_COLOR": "never",
    "RUST_LOG": "off",
    "NPM_CONFIG_PROGRESS": "false",
}
STRACE_EXE = "strace"
UNSHARE_EXE = "unshare"


def which(cmd: str) -> Optional[str]:
    return shutil.which(cmd)


def safe_mkdir(p: Path):
    p.mkdir(parents=True, exist_ok=True)


def redact_env(env: Dict[str, str]) -> Dict[str, str]:
    red = {}
    for k, v in env.items():
        if k in SENSITIVE_ENV_EXACT:
            continue
        if any(k.upper().startswith(pref) for pref in SENSITIVE_ENV_PREFIXES):
            continue
        red[k] = v
    return red


def expand_sensitive_paths(home: str) -> List[str]:
    res = []
    for p in SENSITIVE_PATHS:
        if p.startswith("~"):
            res.append(str(Path(home).joinpath(p[2:]).resolve()))
        else:
            res.append(p)
    return res


def compute_sha256(fp: Path) -> str:
    h = hashlib.sha256()
    with fp.open("rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()


def now_iso() -> str:
    return time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())


class EgressProxy(threading.Thread):
    """
    Minimal HTTP/HTTPS CONNECT proxy with domain allowlist.
    It allows tunneling only to hosts whose hostname matches the allowed suffixes.
    """
    def __init__(self, allowlist: List[str], host: str = "127.0.0.1", port: int = 0):
        super().__init__(daemon=True)
        self.allowlist = [d.lower().lstrip(".") for d in allowlist]
        self.host = host
        self.port = port
        self.sock = None
        self._stop = threading.Event()
        self.active_conns = []

    def _allowed_host(self, host: str) -> bool:
        host = host.lower()
        # Block pure IP by default unless allowlist contains that exact IP.
        try:
            socket.inet_aton(host)
            return host in self.allowlist
        except OSError:
            pass
        return any(host == d or host.endswith("." + d) for d in self.allowlist)

    def run(self):
        with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.bind((self.host, self.port))
            s.listen(100)
            self.sock = s
            self.port = s.getsockname()[1]
            while not self._stop.is_set():
                try:
                    s.settimeout(1.0)
                    client, addr = s.accept()
                except socket.timeout:
                    continue
                t = threading.Thread(target=self.handle_client, args=(client, addr), daemon=True)
                self.active_conns.append(t)
                t.start()

    def stop(self):
        self._stop.set()
        if self.sock:
            try:
                self.sock.shutdown(socket.SHUT_RDWR)
            except Exception:
                pass
            try:
                self.sock.close()
            except Exception:
                pass

    def handle_client(self, client: socket.socket, addr):
        client.settimeout(15)
        try:
            first = self._read_line(client)
            if not first:
                client.close()
                return
            parts = first.strip().split()
            if len(parts) < 2:
                self._deny(client, "400 Bad Request")
                return
            method = parts[0].upper()
            if method == "CONNECT":
                target = parts[1]
                if ":" in target:
                    host, port = target.split(":", 1)
                    try:
                        port = int(port)
                    except ValueError:
                        self._deny(client, "400 Bad Request")
                        return
                else:
                    host, port = target, 443
                if not self._allowed_host(host):
                    self._deny(client, "403 Forbidden")
                    return
                upstream = socket.create_connection((host, port), timeout=20)
                client.sendall(b"HTTP/1.1 200 Connection Established\r\n\r\n")
                self._pipe_bidirectional(client, upstream)
            else:
                # Parse simple HTTP request with absolute URL or relative with Host header
                headers = self._read_headers(client)
                host_header = headers.get("host", "")
                url = parts[1]
                host, port = None, None
                if url.startswith("http://") or url.startswith("https://"):
                    try:
                        scheme, rest = url.split("://", 1)
                        hostport, _ = (rest.split("/", 1) + [""])[:2]
                        if ":" in hostport:
                            host, port = hostport.split(":", 1)
                            port = int(port)
                        else:
                            host, port = hostport, (443 if scheme == "https" else 80)
                    except Exception:
                        self._deny(client, "400 Bad Request")
                        return
                elif host_header:
                    host = host_header
                    port = 80
                else:
                    self._deny(client, "400 Bad Request")
                    return
                if not self._allowed_host(host):
                    self._deny(client, "403 Forbidden")
                    return
                upstream = socket.create_connection((host, port), timeout=20)
                # Reconstruct request path to be relative
                if url.startswith("http://") or url.startswith("https://"):
                    try:
                        path = "/" + url.split("://", 1)[1].split("/", 1)[1]
                    except Exception:
                        path = "/"
                else:
                    path = url
                request_line = f"{method} {path} HTTP/1.1\r\n"
                upstream.sendall(request_line.encode("ascii"))
                # Forward headers and the rest of buffer
                for k, v in headers.items():
                    upstream.sendall(f"{k}: {v}\r\n".encode("latin1"))
                upstream.sendall(b"\r\n")
                self._pipe_bidirectional(client, upstream)
        except Exception:
            try:
                client.close()
            except Exception:
                pass

    def _read_line(self, s: socket.socket) -> str:
        data = b""
        while b"\r\n" not in data:
            chunk = s.recv(1)
            if not chunk:
                break
            data += chunk
            if len(data) > 65536:
                break
        return data.decode("latin1", errors="ignore")

    def _read_headers(self, s: socket.socket) -> Dict[str, str]:
        headers = {}
        # Already consumed request line before calling this in handle_client
        while True:
            line = self._read_line(s)
            if line in ("\r\n", "", None):
                break
            if ":" in line:
                k, v = line.split(":", 1)
                headers[k.strip().lower()] = v.strip()
        return headers

    def _deny(self, client: socket.socket, status: str):
        try:
            client.sendall(f"HTTP/1.1 {status}\r\nContent-Length: 0\r\n\r\n".encode("ascii"))
        except Exception:
            pass
        try:
            client.close()
        except Exception:
            pass

    def _pipe_bidirectional(self, a: socket.socket, b: socket.socket):
        a.settimeout(30)
        b.settimeout(30)

        def forward(src, dst):
            try:
                while True:
                    data = src.recv(4096)
                    if not data:
                        break
                    dst.sendall(data)
            except Exception:
                pass
            try:
                dst.shutdown(socket.SHUT_WR)
            except Exception:
                pass

        t1 = threading.Thread(target=forward, args=(a, b), daemon=True)
        t2 = threading.Thread(target=forward, args=(b, a), daemon=True)
        t1.start(); t2.start()
        t1.join(timeout=60); t2.join(timeout=60)
        try:
            a.close()
        except Exception:
            pass
        try:
            b.close()
        except Exception:
            pass


class TraceEvent:
    def __init__(self, kind: str, detail: str, severity: str, data: Dict):
        self.kind = kind
        self.detail = detail
        self.severity = severity
        self.data = data

    def to_dict(self):
        return {"kind": self.kind, "detail": self.detail, "severity": self.severity, "data": self.data}


class TraceParser:
    CONNECT_RE = re.compile(r'connect\([^,]+, \{sa_family=AF_INET6?, .*?sin_port=htons\((\d+)\), .*?((?:sin_addr=inet_addr\("(?P<ipv4>[^"]+)"\))|(?:sin6_addr=inet_pton\(AF_INET6, "(?P<ipv6>[^"]+)"\))).*?\}')
    OPEN_RE = re.compile(r'open(?:at)?\([^"]*"([^"]+)"')
    GETADDRINFO_RE = re.compile(r'getaddrinfo\("([^"]+)"')
    EXECVE_RE = re.compile(r'execve\("([^"]+)", \[([^\]]*)\]')

    def __init__(self, trace_dir: Path, sensitive_paths: List[str]):
        self.trace_dir = trace_dir
        self.sensitive_paths = sensitive_paths
        self.events: List[TraceEvent] = []

    def parse(self):
        for f in self.trace_dir.glob("trace*.log"):
            try:
                with f.open("r", errors="ignore") as fh:
                    for line in fh:
                        self._parse_line(line.strip())
            except Exception:
                continue
        return self.events

    def _parse_line(self, line: str):
        m = self.CONNECT_RE.search(line)
        if m:
            port = int(m.group(1))
            ip = m.group("ipv4") or m.group("ipv6")
            self.events.append(TraceEvent(
                "network_connect",
                f"Process attempted network connect to {ip}:{port}",
                "high",
                {"ip": ip, "port": port, "raw": line},
            ))
            return
        m2 = self.GETADDRINFO_RE.search(line)
        if m2:
            host = m2.group(1)
            self.events.append(TraceEvent(
                "dns_query",
                f"Process attempted DNS resolution for {host}",
                "medium",
                {"host": host, "raw": line},
            ))
            return
        m3 = self.OPEN_RE.search(line)
        if m3:
            path = m3.group(1)
            for sp in self.sensitive_paths:
                try:
                    if Path(path).resolve().as_posix().startswith(Path(sp).resolve().as_posix()):
                        self.events.append(TraceEvent(
                            "sensitive_file_access",
                            f"Tried to access sensitive path: {path}",
                            "high",
                            {"path": path, "raw": line},
                        ))
                        return
                except Exception:
                    # Non-existent path or permission issue; still compare string contains
                    if path.startswith(sp):
                        self.events.append(TraceEvent(
                            "sensitive_file_access",
                            f"Tried to access sensitive path: {path}",
                            "high",
                            {"path": path, "raw": line},
                        ))
                        return
        m4 = self.EXECVE_RE.search(line)
        if m4:
            exe = m4.group(1)
            argv = m4.group(2)
            base = os.path.basename(exe)
            if base in ("curl", "wget", "powershell", "pwsh", "bitsadmin"):
                self.events.append(TraceEvent(
                    "suspicious_tool_exec",
                    f"Execution of network utility: {base}",
                    "high",
                    {"exe": exe, "argv": argv, "raw": line},
                ))


class HermeticBuildWatchdog:
    def __init__(
        self,
        project_path: Path,
        system: str = "auto",
        allow_egress_domains: Optional[List[str]] = None,
        output_dir: Optional[Path] = None,
        baseline_file: Optional[Path] = None,
        attest: bool = False,
        timeout: int = 1800,
    ):
        self.project_path = project_path.resolve()
        self.system = system
        self.allow_egress_domains = allow_egress_domains or []
        self.output_dir = (output_dir or self.project_path.joinpath(".watchdog_out")).resolve()
        self.baseline_file = baseline_file
        self.attest = attest
        self.timeout = timeout

        self.workdir = Path(tempfile.mkdtemp(prefix="hbw-work-"))
        self.trace_dir = self.workdir.joinpath("traces")
        safe_mkdir(self.trace_dir)
        safe_mkdir(self.output_dir)

        self.env = self._prepare_env()
        self.proxy: Optional[EgressProxy] = None
        self.violations: List[TraceEvent] = []
        self.report: Dict = {}

    def _prepare_env(self) -> Dict[str, str]:
        env = os.environ.copy()
        env = redact_env(env)
        env.update(DEFAULT_REPRO_SEED_ENV)
        # dedicated temp HOME without secrets
        home = self.workdir.joinpath("home")
        safe_mkdir(home)
        env["HOME"] = str(home)
        # VCS safe directory for npm/git if needed
        env["GIT_CONFIG_GLOBAL"] = str(home.joinpath(".gitconfig"))
        # tool caches
        env["PIP_CACHE_DIR"] = str(self.workdir.joinpath("pip-cache"))
        env["CARGO_HOME"] = str(self.workdir.joinpath("cargo-home"))
        env["RUSTUP_HOME"] = str(self.workdir.joinpath("rustup-home"))
        env["NPM_CONFIG_CACHE"] = str(self.workdir.joinpath("npm-cache"))
        env["NPM_CONFIG_AUDIT"] = "false"
        env["NPM_CONFIG_FUND"] = "false"
        # Proxy: if allowlist provided, enable proxy and do NOT set no_proxy
        if self.allow_egress_domains:
            # Start local proxy
            self.proxy = EgressProxy(self.allow_egress_domains)
            self.proxy.start()
            # Wait for port
            t0 = time.time()
            while self.proxy.port == 0 and time.time() - t0 < 5:
                time.sleep(0.05)
            proxy_url = f"http://127.0.0.1:{self.proxy.port}"
            env["HTTP_PROXY"] = proxy_url
            env["HTTPS_PROXY"] = proxy_url
            env["NO_PROXY"] = ""
        else:
            # Ensure proxies are not inherited
            env.pop("HTTP_PROXY", None)
            env.pop("HTTPS_PROXY", None)
            env["NO_PROXY"] = "*"
        return env

    def _detect_system(self) -> str:
        if self.system != "auto":
            return self.system
        if self.project_path.joinpath("package.json").exists():
            return "npm"
        if self.project_path.joinpath("Cargo.toml").exists():
            return "cargo"
        if self.project_path.joinpath("setup.py").exists() or self.project_path.joinpath("pyproject.toml").exists():
            return "pip"
        # default to pip as conservative
        return "pip"

    def _copy_project(self) -> Path:
        dest = self.workdir.joinpath("workspace")
        shutil.copytree(self.project_path, dest, dirs_exist_ok=True)
        return dest

    def _build_command(self, system: str) -> List[str]:
        if system == "npm":
            return ["npm", "ci"]
        if system == "pip":
            return ["pip", "install", "."]
        if system == "cargo":
            return ["cargo", "build", "--locked"]
        return ["true"]

    def _wrap_with_strace(self, cmd: List[str]) -> List[str]:
        if which(STRACE_EXE) is None:
            return cmd
        # strace -ff -o trace_dir/trace -s 200 -tt -qq --
        trace_prefix = str(self.trace_dir.joinpath("trace"))
        return [STRACE_EXE, "-ff", "-o", trace_prefix, "-s", "200", "-tt", "-qq", "--"] + cmd

    def _wrap_with_unshare(self, cmd: List[str], disable_network: bool) -> List[str]:
        if which(UNSHARE_EXE) is None:
            return cmd
        flags = ["-Ur", "-m"]
        if disable_network:
            flags.append("-n")
        # Unshare and exec command
        return [UNSHARE_EXE] + flags + ["--"] + cmd

    def _spawn(self, cmd: List[str], cwd: Path) -> Tuple[int, str, str]:
        try:
            p = subprocess.Popen(
                cmd,
                cwd=str(cwd),
                env=self.env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
            try:
                out, err = p.communicate(timeout=self.timeout)
            except subprocess.TimeoutExpired:
                p.kill()
                out, err = p.communicate()
                return 124, out, err + "\nERROR: Build timed out."
            return p.returncode, out, err
        except FileNotFoundError as e:
            return 127, "", f"ERROR: Command not found: {e}"
        except Exception as e:
            return 1, "", f"ERROR: Failed to spawn: {e}"

    def run_build(self) -> Tuple[int, str, str]:
        system = self._detect_system()
        workspace = self._copy_project()
        cmd = self._build_command(system)
        # If no allowlist -> enforce network off using unshare if available
        disable_network = not bool(self.allow_egress_domains)
        real_cmd = cmd
        real_cmd = self._wrap_with_strace(real_cmd)
        real_cmd = self._wrap_with_unshare(real_cmd, disable_network=disable_network)
        rc, out, err = self._spawn(real_cmd, cwd=workspace)
        # Ensure proxy cleanup
        if self.proxy:
            self.proxy.stop()
        # Save logs
        (self.output_dir / "stdout.log").write_text(out or "", encoding="utf-8")
        (self.output_dir / "stderr.log").write_text(err or "", encoding="utf-8")
        return rc, out, err

    def analyze_behavior(self):
        # Parse traces
        sensitive_paths = expand_sensitive_paths(self.env.get("HOME", ""))
        parser = TraceParser(self.trace_dir, sensitive_paths)
        events = parser.parse()
        violations = []
        for ev in events:
            if ev.kind == "network_connect":
                # If egress disabled: any connect is violation
                if not self.allow_egress_domains:
                    violations.append(ev)
                else:
                    # If proxy mode: connecting to non-localhost likely bypass
                    ip = ev.data.get("ip", "")
                    if ip not in ("127.0.0.1", "::1"):
                        violations.append(TraceEvent(
                            "egress_bypass", f"Direct egress detected to {ip}", "high", ev.data
                        ))
            elif ev.kind == "sensitive_file_access":
                violations.append(ev)
            elif ev.kind == "suspicious_tool_exec":
                violations.append(ev)
        self.violations = violations
        # Write behavior report
        report = {
            "timestamp": now_iso(),
            "project": str(self.project_path),
            "events": [e.to_dict() for e in events],
            "violations": [v.to_dict() for v in violations],
            "ethics": ETHICAL_WARNING,
        }
        (self.output_dir / "behavior_report.json").write_text(json.dumps(report, indent=2), encoding="utf-8")
        self.report = report
        return violations

    def generate_sbom(self) -> Path:
        # Simple file-list SBOM (CycloneDX-like)
        workspace = self.workdir.joinpath("workspace")
        components = []
        for root, dirs, files in os.walk(workspace):
            for name in files:
                fp = Path(root).joinpath(name)
                try:
                    sha = compute_sha256(fp)
                    components.append({
                        "name": str(fp.relative_to(workspace).as_posix()),
                        "hashes": [{"alg": "SHA-256", "content": sha}],
                        "size": fp.stat().st_size,
                    })
                except Exception:
                    continue
        sbom = {
            "bomFormat": "CycloneDX",
            "specVersion": "1.4",
            "version": 1,
            "metadata": {"timestamp": now_iso(), "component": {"name": self.project_path.name}},
            "components": components,
        }
        out = self.output_dir / "sbom.cdx.json"
        out.write_text(json.dumps(sbom, indent=2), encoding="utf-8")
        return out

    def diff_sbom(self, sbom_path: Path) -> Dict:
        diff = {"added": [], "removed": [], "changed": []}
        try:
            current = json.loads(sbom_path.read_text(encoding="utf-8"))
        except Exception:
            return diff
        baseline = None
        if self.baseline_file and self.baseline_file.exists():
            try:
                baseline = json.loads(self.baseline_file.read_text(encoding="utf-8"))
            except Exception:
                baseline = None
        if not baseline:
            return diff
        base_map = {c["name"]: c for c in baseline.get("components", [])}
        cur_map = {c["name"]: c for c in current.get("components", [])}
        for name in cur_map:
            if name not in base_map:
                diff["added"].append(name)
            else:
                old = base_map[name]["hashes"][0]["content"]
                new = cur_map[name]["hashes"][0]["content"]
                if old != new:
                    diff["changed"].append(name)
        for name in base_map:
            if name not in cur_map:
                diff["removed"].append(name)
        (self.output_dir / "sbom_diff.json").write_text(json.dumps(diff, indent=2), encoding="utf-8")
        return diff

    def sign_attestation(self, status: str, sbom_path: Optional[Path], violations: List[TraceEvent]) -> Optional[Path]:
        attestation = {
            "tool": "HermeticBuild Watchdog",
            "timestamp": now_iso(),
            "project": str(self.project_path),
            "status": status,
            "violations": [v.to_dict() for v in violations],
            "sbom": str(sbom_path) if sbom_path else None,
        }
        att_path = self.output_dir / "attestation.json"
        att_path.write_text(json.dumps(attestation, indent=2), encoding="utf-8")
        if not self.attest:
            return att_path
        # Try sigstore CLI
        sig_path = self.output_dir / "attestation.sig"
        sigstore_cli = which("sigstore")
        if not sigstore_cli:
            # Try python -m sigstore
            py = which(sys.executable.split(os.sep)[-1]) or sys.executable
            try:
                rc = subprocess.call([py, "-m", "sigstore", "sign", "--output", str(sig_path), str(att_path)])
                if rc == 0:
                    return sig_path
                return att_path
            except Exception:
                return att_path
        try:
            rc = subprocess.call([sigstore_cli, "sign", "--output", str(sig_path), str(att_path)])
            if rc == 0:
                return sig_path
        except Exception:
            pass
        return att_path

    def quarantine(self):
        quarantine_flag = self.output_dir / "QUARANTINED"
        quarantine_flag.write_text("Build quarantined due to policy violations.\n", encoding="utf-8")

    def run(self) -> int:
        print(ETHICAL_WARNING, file=sys.stderr)
        rc, out, err = self.run_build()
        # Analyze
        violations = self.analyze_behavior()
        # SBOM
        sbom = self.generate_sbom()
        diff = self.diff_sbom(sbom)
        # Decide status
        status = "pass"
        if rc != 0:
            status = "build_failed"
        if violations:
            status = "policy_violation"
        if status != "pass":
            self.quarantine()
        self.sign_attestation(status, sbom, violations)
        # Write summary
        summary = {
            "timestamp": now_iso(),
            "status": status,
            "return_code": rc,
            "violations_count": len(violations),
            "sbom_path": str(sbom),
            "sbom_diff": diff,
            "output_dir": str(self.output_dir),
        }
        (self.output_dir / "summary.json").write_text(json.dumps(summary, indent=2), encoding="utf-8")
        # High severity if:
        if any(v.severity == "high" for v in violations):
            return 10
        return 0 if status == "pass" else 1


def parse_args(argv: List[str]) -> argparse.Namespace:
    p = argparse.ArgumentParser(description="HermeticBuild Watchdog: CI/CD Script Behavior Sandbox")
    p.add_argument("--path", required=True, help="Path to project root")
    p.add_argument("--system", choices=["auto", "npm", "pip", "cargo"], default="auto", help="Build system")
    p.add_argument("--allow-egress", default="", help="Comma-separated allowed egress domains (enables proxy mode)")
    p.add_argument("--output", default="", help="Output directory for reports")
    p.add_argument("--baseline", default="", help="Baseline SBOM to diff against")
    p.add_argument("--attest", action="store_true", help="Emit Sigstore-signed attestation if possible")
    p.add_argument("--timeout", type=int, default=1800, help="Build timeout seconds")
    return p.parse_args(argv)


def main(argv: List[str]) -> int:
    args = parse_args(argv)
    project = Path(args.path)
    if not project.exists():
        print(f"ERROR: Project path does not exist: {project}", file=sys.stderr)
        return 2
    outdir = Path(args.output) if args.output else project.joinpath(".watchdog_out")
    baseline = Path(args.baseline) if args.baseline else None
    allow = [d.strip() for d in args.allow_egress.split(",") if d.strip()]
    tool = HermeticBuildWatchdog(
        project_path=project,
        system=args.system,
        allow_egress_domains=allow,
        output_dir=outdir,
        baseline_file=baseline,
        attest=args.attest,
        timeout=args.timeout,
    )
    try:
        return tool.run()
    except KeyboardInterrupt:
        print("Interrupted.", file=sys.stderr)
        return 130
    except Exception as e:
        # Ensure ethical warning emphasized in errors
        try:
            (tool.output_dir / "error.log").write_text(f"{ETHICAL_WARNING}\nERROR: {e}\n", encoding="utf-8")
        except Exception:
            pass
        print(f"ERROR: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))